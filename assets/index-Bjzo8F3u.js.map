{"version":3,"file":"index-Bjzo8F3u.js","sources":["../../node_modules/minisearch/dist/es/index.js"],"sourcesContent":["/** @ignore */\nconst ENTRIES = 'ENTRIES';\n/** @ignore */\nconst KEYS = 'KEYS';\n/** @ignore */\nconst VALUES = 'VALUES';\n/** @ignore */\nconst LEAF = '';\n/**\n * @private\n */\nclass TreeIterator {\n    constructor(set, type) {\n        const node = set._tree;\n        const keys = Array.from(node.keys());\n        this.set = set;\n        this._type = type;\n        this._path = keys.length > 0 ? [{ node, keys }] : [];\n    }\n    next() {\n        const value = this.dive();\n        this.backtrack();\n        return value;\n    }\n    dive() {\n        if (this._path.length === 0) {\n            return { done: true, value: undefined };\n        }\n        const { node, keys } = last$1(this._path);\n        if (last$1(keys) === LEAF) {\n            return { done: false, value: this.result() };\n        }\n        const child = node.get(last$1(keys));\n        this._path.push({ node: child, keys: Array.from(child.keys()) });\n        return this.dive();\n    }\n    backtrack() {\n        if (this._path.length === 0) {\n            return;\n        }\n        const keys = last$1(this._path).keys;\n        keys.pop();\n        if (keys.length > 0) {\n            return;\n        }\n        this._path.pop();\n        this.backtrack();\n    }\n    key() {\n        return this.set._prefix + this._path\n            .map(({ keys }) => last$1(keys))\n            .filter(key => key !== LEAF)\n            .join('');\n    }\n    value() {\n        return last$1(this._path).node.get(LEAF);\n    }\n    result() {\n        switch (this._type) {\n            case VALUES: return this.value();\n            case KEYS: return this.key();\n            default: return [this.key(), this.value()];\n        }\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nconst last$1 = (array) => {\n    return array[array.length - 1];\n};\n\n/* eslint-disable no-labels */\n/**\n * @ignore\n */\nconst fuzzySearch = (node, query, maxDistance) => {\n    const results = new Map();\n    if (query === undefined)\n        return results;\n    // Number of columns in the Levenshtein matrix.\n    const n = query.length + 1;\n    // Matching terms can never be longer than N + maxDistance.\n    const m = n + maxDistance;\n    // Fill first matrix row and column with numbers: 0 1 2 3 ...\n    const matrix = new Uint8Array(m * n).fill(maxDistance + 1);\n    for (let j = 0; j < n; ++j)\n        matrix[j] = j;\n    for (let i = 1; i < m; ++i)\n        matrix[i * n] = i;\n    recurse(node, query, maxDistance, results, matrix, 1, n, '');\n    return results;\n};\n// Modified version of http://stevehanov.ca/blog/?id=114\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\nconst recurse = (node, query, maxDistance, results, matrix, m, n, prefix) => {\n    const offset = m * n;\n    key: for (const key of node.keys()) {\n        if (key === LEAF) {\n            // We've reached a leaf node. Check if the edit distance acceptable and\n            // store the result if it is.\n            const distance = matrix[offset - 1];\n            if (distance <= maxDistance) {\n                results.set(prefix, [node.get(key), distance]);\n            }\n        }\n        else {\n            // Iterate over all characters in the key. Update the Levenshtein matrix\n            // and check if the minimum distance in the last row is still within the\n            // maximum edit distance. If it is, we can recurse over all child nodes.\n            let i = m;\n            for (let pos = 0; pos < key.length; ++pos, ++i) {\n                const char = key[pos];\n                const thisRowOffset = n * i;\n                const prevRowOffset = thisRowOffset - n;\n                // Set the first column based on the previous row, and initialize the\n                // minimum distance in the current row.\n                let minDistance = matrix[thisRowOffset];\n                const jmin = Math.max(0, i - maxDistance - 1);\n                const jmax = Math.min(n - 1, i + maxDistance);\n                // Iterate over remaining columns (characters in the query).\n                for (let j = jmin; j < jmax; ++j) {\n                    const different = char !== query[j];\n                    // It might make sense to only read the matrix positions used for\n                    // deletion/insertion if the characters are different. But we want to\n                    // avoid conditional reads for performance reasons.\n                    const rpl = matrix[prevRowOffset + j] + +different;\n                    const del = matrix[prevRowOffset + j + 1] + 1;\n                    const ins = matrix[thisRowOffset + j] + 1;\n                    const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);\n                    if (dist < minDistance)\n                        minDistance = dist;\n                }\n                // Because distance will never decrease, we can stop. There will be no\n                // matching child nodes.\n                if (minDistance > maxDistance) {\n                    continue key;\n                }\n            }\n            recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);\n        }\n    }\n};\n\n/* eslint-disable no-labels */\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nclass SearchableMap {\n    /**\n     * The constructor is normally called without arguments, creating an empty\n     * map. In order to create a {@link SearchableMap} from an iterable or from an\n     * object, check {@link SearchableMap.from} and {@link\n     * SearchableMap.fromObject}.\n     *\n     * The constructor arguments are for internal use, when creating derived\n     * mutable views of a map at a prefix.\n     */\n    constructor(tree = new Map(), prefix = '') {\n        this._size = undefined;\n        this._tree = tree;\n        this._prefix = prefix;\n    }\n    /**\n     * Creates and returns a mutable view of this {@link SearchableMap},\n     * containing only entries that share the given prefix.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set(\"unicorn\", 1)\n     * map.set(\"universe\", 2)\n     * map.set(\"university\", 3)\n     * map.set(\"unique\", 4)\n     * map.set(\"hello\", 5)\n     *\n     * let uni = map.atPrefix(\"uni\")\n     * uni.get(\"unique\") // => 4\n     * uni.get(\"unicorn\") // => 1\n     * uni.get(\"hello\") // => undefined\n     *\n     * let univer = map.atPrefix(\"univer\")\n     * univer.get(\"unique\") // => undefined\n     * univer.get(\"universe\") // => 2\n     * univer.get(\"university\") // => 3\n     * ```\n     *\n     * @param prefix  The prefix\n     * @return A {@link SearchableMap} representing a mutable view of the original\n     * Map at the given prefix\n     */\n    atPrefix(prefix) {\n        if (!prefix.startsWith(this._prefix)) {\n            throw new Error('Mismatched prefix');\n        }\n        const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length));\n        if (node === undefined) {\n            const [parentNode, key] = last(path);\n            for (const k of parentNode.keys()) {\n                if (k !== LEAF && k.startsWith(key)) {\n                    const node = new Map();\n                    node.set(k.slice(key.length), parentNode.get(k));\n                    return new SearchableMap(node, prefix);\n                }\n            }\n        }\n        return new SearchableMap(node, prefix);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n     */\n    clear() {\n        this._size = undefined;\n        this._tree.clear();\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n     * @param key  Key to delete\n     */\n    delete(key) {\n        this._size = undefined;\n        return remove(this._tree, key);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n     * @return An iterator iterating through `[key, value]` entries.\n     */\n    entries() {\n        return new TreeIterator(this, ENTRIES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n     * @param fn  Iteration function\n     */\n    forEach(fn) {\n        for (const [key, value] of this) {\n            fn(key, value, this);\n        }\n    }\n    /**\n     * Returns a Map of all the entries that have a key within the given edit\n     * distance from the search key. The keys of the returned Map are the matching\n     * keys, while the values are two-element arrays where the first element is\n     * the value associated to the key, and the second is the edit distance of the\n     * key to the search key.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set('hello', 'world')\n     * map.set('hell', 'yeah')\n     * map.set('ciao', 'mondo')\n     *\n     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n     * map.fuzzyGet('hallo', 2)\n     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n     *\n     * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n     * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n     * // (change \"e\" to \"a\", delete \"o\")\n     * ```\n     *\n     * @param key  The search key\n     * @param maxEditDistance  The maximum edit distance (Levenshtein)\n     * @return A Map of the matching keys to their value and edit distance\n     */\n    fuzzyGet(key, maxEditDistance) {\n        return fuzzySearch(this._tree, key, maxEditDistance);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n     * @param key  Key to get\n     * @return Value associated to the key, or `undefined` if the key is not\n     * found.\n     */\n    get(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined ? node.get(LEAF) : undefined;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n     * @param key  Key\n     * @return True if the key is in the map, false otherwise\n     */\n    has(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined && node.has(LEAF);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n     * @return An `Iterable` iterating through keys\n     */\n    keys() {\n        return new TreeIterator(this, KEYS);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n     * @param key  Key to set\n     * @param value  Value to associate to the key\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    set(key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, value);\n        return this;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n     */\n    get size() {\n        if (this._size) {\n            return this._size;\n        }\n        /** @ignore */\n        this._size = 0;\n        const iter = this.entries();\n        while (!iter.next().done)\n            this._size += 1;\n        return this._size;\n    }\n    /**\n     * Updates the value at the given key using the provided function. The function\n     * is called with the current value at the key, and its return value is used as\n     * the new value to be set.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * // Increment the current value by one\n     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n     * ```\n     *\n     * If the value at the given key is or will be an object, it might not require\n     * re-assignment. In that case it is better to use `fetch()`, because it is\n     * faster.\n     *\n     * @param key  The key to update\n     * @param fn  The function used to compute the new value from the current one\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    update(key, fn) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, fn(node.get(LEAF)));\n        return this;\n    }\n    /**\n     * Fetches the value of the given key. If the value does not exist, calls the\n     * given function to create a new value, which is inserted at the given key\n     * and subsequently returned.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * const map = searchableMap.fetch('somekey', () => new Map())\n     * map.set('foo', 'bar')\n     * ```\n     *\n     * @param key  The key to update\n     * @param initial  A function that creates a new value if the key does not exist\n     * @return The existing or new value at the given key\n     */\n    fetch(key, initial) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        let value = node.get(LEAF);\n        if (value === undefined) {\n            node.set(LEAF, value = initial());\n        }\n        return value;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n     * @return An `Iterable` iterating through values.\n     */\n    values() {\n        return new TreeIterator(this, VALUES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Creates a {@link SearchableMap} from an `Iterable` of entries\n     *\n     * @param entries  Entries to be inserted in the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static from(entries) {\n        const tree = new SearchableMap();\n        for (const [key, value] of entries) {\n            tree.set(key, value);\n        }\n        return tree;\n    }\n    /**\n     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n     *\n     * @param object  Object of entries for the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static fromObject(object) {\n        return SearchableMap.from(Object.entries(object));\n    }\n}\nconst trackDown = (tree, key, path = []) => {\n    if (key.length === 0 || tree == null) {\n        return [tree, path];\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            path.push([tree, k]); // performance: update in place\n            return trackDown(tree.get(k), key.slice(k.length), path);\n        }\n    }\n    path.push([tree, key]); // performance: update in place\n    return trackDown(undefined, '', path);\n};\nconst lookup = (tree, key) => {\n    if (key.length === 0 || tree == null) {\n        return tree;\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            return lookup(tree.get(k), key.slice(k.length));\n        }\n    }\n};\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = (node, key) => {\n    const keyLength = key.length;\n    outer: for (let pos = 0; node && pos < keyLength;) {\n        for (const k of node.keys()) {\n            // Check whether this key is a candidate: the first characters must match.\n            if (k !== LEAF && key[pos] === k[0]) {\n                const len = Math.min(keyLength - pos, k.length);\n                // Advance offset to the point where key and k no longer match.\n                let offset = 1;\n                while (offset < len && key[pos + offset] === k[offset])\n                    ++offset;\n                const child = node.get(k);\n                if (offset === k.length) {\n                    // The existing key is shorter than the key we need to create.\n                    node = child;\n                }\n                else {\n                    // Partial match: we need to insert an intermediate node to contain\n                    // both the existing subtree and the new node.\n                    const intermediate = new Map();\n                    intermediate.set(k.slice(offset), child);\n                    node.set(key.slice(pos, pos + offset), intermediate);\n                    node.delete(k);\n                    node = intermediate;\n                }\n                pos += offset;\n                continue outer;\n            }\n        }\n        // Create a final child node to contain the final suffix of the key.\n        const child = new Map();\n        node.set(key.slice(pos), child);\n        return child;\n    }\n    return node;\n};\nconst remove = (tree, key) => {\n    const [node, path] = trackDown(tree, key);\n    if (node === undefined) {\n        return;\n    }\n    node.delete(LEAF);\n    if (node.size === 0) {\n        cleanup(path);\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        merge(path, key, value);\n    }\n};\nconst cleanup = (path) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, key] = last(path);\n    node.delete(key);\n    if (node.size === 0) {\n        cleanup(path.slice(0, -1));\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        if (key !== LEAF) {\n            merge(path.slice(0, -1), key, value);\n        }\n    }\n};\nconst merge = (path, key, value) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, nodeKey] = last(path);\n    node.set(nodeKey + key, value);\n    node.delete(nodeKey);\n};\nconst last = (array) => {\n    return array[array.length - 1];\n};\n\nconst OR = 'or';\nconst AND = 'and';\nconst AND_NOT = 'and_not';\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nclass MiniSearch {\n    /**\n     * @param options  Configuration options\n     *\n     * ### Examples:\n     *\n     * ```javascript\n     * // Create a search engine that indexes the 'title' and 'text' fields of your\n     * // documents:\n     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * ```\n     *\n     * ### ID Field:\n     *\n     * ```javascript\n     * // Your documents are assumed to include a unique 'id' field, but if you want\n     * // to use a different field for document identification, you can set the\n     * // 'idField' option:\n     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n     * ```\n     *\n     * ### Options and defaults:\n     *\n     * ```javascript\n     * // The full set of options (here with their default value) is:\n     * const miniSearch = new MiniSearch({\n     *   // idField: field that uniquely identifies a document\n     *   idField: 'id',\n     *\n     *   // extractField: function used to get the value of a field in a document.\n     *   // By default, it assumes the document is a flat object with field names as\n     *   // property keys and field values as string property values, but custom logic\n     *   // can be implemented by setting this option to a custom extractor function.\n     *   extractField: (document, fieldName) => document[fieldName],\n     *\n     *   // tokenize: function used to split fields into individual terms. By\n     *   // default, it is also used to tokenize search queries, unless a specific\n     *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n     *   // the field name is passed as the second argument.\n     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n     *\n     *   // processTerm: function used to process each tokenized term before\n     *   // indexing. It can be used for stemming and normalization. Return a falsy\n     *   // value in order to discard a term. By default, it is also used to process\n     *   // search queries, unless a specific `processTerm` option is supplied as a\n     *   // search option. When processing a term from a indexed field, the field\n     *   // name is passed as the second argument.\n     *   processTerm: (term, _fieldName) => term.toLowerCase(),\n     *\n     *   // searchOptions: default search options, see the `search` method for\n     *   // details\n     *   searchOptions: undefined,\n     *\n     *   // fields: document fields to be indexed. Mandatory, but not set by default\n     *   fields: undefined\n     *\n     *   // storeFields: document fields to be stored and returned as part of the\n     *   // search results.\n     *   storeFields: []\n     * })\n     * ```\n     */\n    constructor(options) {\n        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {\n            throw new Error('MiniSearch: option \"fields\" must be provided');\n        }\n        const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;\n        this._options = {\n            ...defaultOptions,\n            ...options,\n            autoVacuum,\n            searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n            autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n        };\n        this._index = new SearchableMap();\n        this._documentCount = 0;\n        this._documentIds = new Map();\n        this._idToShortId = new Map();\n        // Fields are defined during initialization, don't change, are few in\n        // number, rarely need iterating over, and have string keys. Therefore in\n        // this case an object is a better candidate than a Map to store the mapping\n        // from field key to ID.\n        this._fieldIds = {};\n        this._fieldLength = new Map();\n        this._avgFieldLength = [];\n        this._nextId = 0;\n        this._storedFields = new Map();\n        this._dirtCount = 0;\n        this._currentVacuum = null;\n        this._enqueuedVacuum = null;\n        this._enqueuedVacuumConditions = defaultVacuumConditions;\n        this.addFields(this._options.fields);\n    }\n    /**\n     * Adds a document to the index\n     *\n     * @param document  The document to be indexed\n     */\n    add(document) {\n        const { extractField, tokenize, processTerm, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        if (this._idToShortId.has(id)) {\n            throw new Error(`MiniSearch: duplicate ID ${id}`);\n        }\n        const shortDocumentId = this.addDocumentId(id);\n        this.saveStoredFields(shortDocumentId, document);\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(fieldValue.toString(), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.addTerm(fieldId, shortDocumentId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.addTerm(fieldId, shortDocumentId, processedTerm);\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the given documents to the index\n     *\n     * @param documents  An array of documents to be indexed\n     */\n    addAll(documents) {\n        for (const document of documents)\n            this.add(document);\n    }\n    /**\n     * Adds all the given documents to the index asynchronously.\n     *\n     * Returns a promise that resolves (to `undefined`) when the indexing is done.\n     * This method is useful when index many documents, to avoid blocking the main\n     * thread. The indexing is performed asynchronously and in chunks.\n     *\n     * @param documents  An array of documents to be indexed\n     * @param options  Configuration options\n     * @return A promise resolving to `undefined` when the indexing is done\n     */\n    addAllAsync(documents, options = {}) {\n        const { chunkSize = 10 } = options;\n        const acc = { chunk: [], promise: Promise.resolve() };\n        const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n            chunk.push(document);\n            if ((i + 1) % chunkSize === 0) {\n                return {\n                    chunk: [],\n                    promise: promise\n                        .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n                        .then(() => this.addAll(chunk))\n                };\n            }\n            else {\n                return { chunk, promise };\n            }\n        }, acc);\n        return promise.then(() => this.addAll(chunk));\n    }\n    /**\n     * Removes the given document from the index.\n     *\n     * The document to remove must NOT have changed between indexing and removal,\n     * otherwise the index will be corrupted.\n     *\n     * This method requires passing the full document to be removed (not just the\n     * ID), and immediately removes the document from the inverted index, allowing\n     * memory to be released. A convenient alternative is {@link\n     * MiniSearch#discard}, which needs only the document ID, and has the same\n     * visible effect, but delays cleaning up the index until the next vacuuming.\n     *\n     * @param document  The document to be removed\n     */\n    remove(document) {\n        const { tokenize, processTerm, extractField, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`);\n        }\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(fieldValue.toString(), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.removeTerm(fieldId, shortId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.removeTerm(fieldId, shortId, processedTerm);\n                }\n            }\n        }\n        this._storedFields.delete(shortId);\n        this._documentIds.delete(shortId);\n        this._idToShortId.delete(id);\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n    }\n    /**\n     * Removes all the given documents from the index. If called with no arguments,\n     * it removes _all_ documents from the index.\n     *\n     * @param documents  The documents to be removed. If this argument is omitted,\n     * all documents are removed. Note that, for removing all documents, it is\n     * more efficient to call this method with no arguments than to pass all\n     * documents.\n     */\n    removeAll(documents) {\n        if (documents) {\n            for (const document of documents)\n                this.remove(document);\n        }\n        else if (arguments.length > 0) {\n            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');\n        }\n        else {\n            this._index = new SearchableMap();\n            this._documentCount = 0;\n            this._documentIds = new Map();\n            this._idToShortId = new Map();\n            this._fieldLength = new Map();\n            this._avgFieldLength = [];\n            this._storedFields = new Map();\n            this._nextId = 0;\n        }\n    }\n    /**\n     * Discards the document with the given ID, so it won't appear in search results\n     *\n     * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n     * document to stop appearing in searches), but a different effect on the\n     * internal data structures:\n     *\n     *   - {@link MiniSearch#remove} requires passing the full document to be\n     *   removed as argument, and removes it from the inverted index immediately.\n     *\n     *   - {@link MiniSearch#discard} instead only needs the document ID, and\n     *   works by marking the current version of the document as discarded, so it\n     *   is immediately ignored by searches. This is faster and more convenient\n     *   than {@link MiniSearch#remove}, but the index is not immediately\n     *   modified. To take care of that, vacuuming is performed after a certain\n     *   number of documents are discarded, cleaning up the index and allowing\n     *   memory to be released.\n     *\n     * After discarding a document, it is possible to re-add a new version, and\n     * only the new version will appear in searches. In other words, discarding\n     * and re-adding a document works exactly like removing and re-adding it. The\n     * {@link MiniSearch.replace} method can also be used to replace a document\n     * with a new version.\n     *\n     * #### Details about vacuuming\n     *\n     * Repetite calls to this method would leave obsolete document references in\n     * the index, invisible to searches. Two mechanisms take care of cleaning up:\n     * clean up during search, and vacuuming.\n     *\n     *   - Upon search, whenever a discarded ID is found (and ignored for the\n     *   results), references to the discarded document are removed from the\n     *   inverted index entries for the search terms. This ensures that subsequent\n     *   searches for the same terms do not need to skip these obsolete references\n     *   again.\n     *\n     *   - In addition, vacuuming is performed automatically by default (see the\n     *   `autoVacuum` field in {@link Options}) after a certain number of\n     *   documents are discarded. Vacuuming traverses all terms in the index,\n     *   cleaning up all references to discarded documents. Vacuuming can also be\n     *   triggered manually by calling {@link MiniSearch#vacuum}.\n     *\n     * @param id  The ID of the document to be discarded\n     */\n    discard(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`);\n        }\n        this._idToShortId.delete(id);\n        this._documentIds.delete(shortId);\n        this._storedFields.delete(shortId);\n        (this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n            this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength);\n        });\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n        this._dirtCount += 1;\n        this.maybeAutoVacuum();\n    }\n    maybeAutoVacuum() {\n        if (this._options.autoVacuum === false) {\n            return;\n        }\n        const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum;\n        this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });\n    }\n    /**\n     * Discards the documents with the given IDs, so they won't appear in search\n     * results\n     *\n     * It is equivalent to calling {@link MiniSearch#discard} for all the given\n     * IDs, but with the optimization of triggering at most one automatic\n     * vacuuming at the end.\n     *\n     * Note: to remove all documents from the index, it is faster and more\n     * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n     * of passing all IDs to this method.\n     */\n    discardAll(ids) {\n        const autoVacuum = this._options.autoVacuum;\n        try {\n            this._options.autoVacuum = false;\n            for (const id of ids) {\n                this.discard(id);\n            }\n        }\n        finally {\n            this._options.autoVacuum = autoVacuum;\n        }\n        this.maybeAutoVacuum();\n    }\n    /**\n     * It replaces an existing document with the given updated version\n     *\n     * It works by discarding the current version and adding the updated one, so\n     * it is functionally equivalent to calling {@link MiniSearch#discard}\n     * followed by {@link MiniSearch#add}. The ID of the updated document should\n     * be the same as the original one.\n     *\n     * Since it uses {@link MiniSearch#discard} internally, this method relies on\n     * vacuuming to clean up obsolete document references from the index, allowing\n     * memory to be released (see {@link MiniSearch#discard}).\n     *\n     * @param updatedDocument  The updated document to replace the old version\n     * with\n     */\n    replace(updatedDocument) {\n        const { idField, extractField } = this._options;\n        const id = extractField(updatedDocument, idField);\n        this.discard(id);\n        this.add(updatedDocument);\n    }\n    /**\n     * Triggers a manual vacuuming, cleaning up references to discarded documents\n     * from the inverted index\n     *\n     * Vacuuming is only useful for applications that use the {@link\n     * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n     *\n     * By default, vacuuming is performed automatically when needed (controlled by\n     * the `autoVacuum` field in {@link Options}), so there is usually no need to\n     * call this method, unless one wants to make sure to perform vacuuming at a\n     * specific moment.\n     *\n     * Vacuuming traverses all terms in the inverted index in batches, and cleans\n     * up references to discarded documents from the posting list, allowing memory\n     * to be released.\n     *\n     * The method takes an optional object as argument with the following keys:\n     *\n     *   - `batchSize`: the size of each batch (1000 by default)\n     *\n     *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n     *   default)\n     *\n     * On large indexes, vacuuming could have a non-negligible cost: batching\n     * avoids blocking the thread for long, diluting this cost so that it is not\n     * negatively affecting the application. Nonetheless, this method should only\n     * be called when necessary, and relying on automatic vacuuming is usually\n     * better.\n     *\n     * It returns a promise that resolves (to undefined) when the clean up is\n     * completed. If vacuuming is already ongoing at the time this method is\n     * called, a new one is enqueued immediately after the ongoing one, and a\n     * corresponding promise is returned. However, no more than one vacuuming is\n     * enqueued on top of the ongoing one, even if this method is called more\n     * times (enqueuing multiple ones would be useless).\n     *\n     * @param options  Configuration options for the batch size and delay. See\n     * {@link VacuumOptions}.\n     */\n    vacuum(options = {}) {\n        return this.conditionalVacuum(options);\n    }\n    conditionalVacuum(options, conditions) {\n        // If a vacuum is already ongoing, schedule another as soon as it finishes,\n        // unless there's already one enqueued. If one was already enqueued, do not\n        // enqueue another on top, but make sure that the conditions are the\n        // broadest.\n        if (this._currentVacuum) {\n            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;\n            if (this._enqueuedVacuum != null) {\n                return this._enqueuedVacuum;\n            }\n            this._enqueuedVacuum = this._currentVacuum.then(() => {\n                const conditions = this._enqueuedVacuumConditions;\n                this._enqueuedVacuumConditions = defaultVacuumConditions;\n                return this.performVacuuming(options, conditions);\n            });\n            return this._enqueuedVacuum;\n        }\n        if (this.vacuumConditionsMet(conditions) === false) {\n            return Promise.resolve();\n        }\n        this._currentVacuum = this.performVacuuming(options);\n        return this._currentVacuum;\n    }\n    async performVacuuming(options, conditions) {\n        const initialDirtCount = this._dirtCount;\n        if (this.vacuumConditionsMet(conditions)) {\n            const batchSize = options.batchSize || defaultVacuumOptions.batchSize;\n            const batchWait = options.batchWait || defaultVacuumOptions.batchWait;\n            let i = 1;\n            for (const [term, fieldsData] of this._index) {\n                for (const [fieldId, fieldIndex] of fieldsData) {\n                    for (const [shortId] of fieldIndex) {\n                        if (this._documentIds.has(shortId)) {\n                            continue;\n                        }\n                        if (fieldIndex.size <= 1) {\n                            fieldsData.delete(fieldId);\n                        }\n                        else {\n                            fieldIndex.delete(shortId);\n                        }\n                    }\n                }\n                if (this._index.get(term).size === 0) {\n                    this._index.delete(term);\n                }\n                if (i % batchSize === 0) {\n                    await new Promise((resolve) => setTimeout(resolve, batchWait));\n                }\n                i += 1;\n            }\n            this._dirtCount -= initialDirtCount;\n        }\n        // Make the next lines always async, so they execute after this function returns\n        await null;\n        this._currentVacuum = this._enqueuedVacuum;\n        this._enqueuedVacuum = null;\n    }\n    vacuumConditionsMet(conditions) {\n        if (conditions == null) {\n            return true;\n        }\n        let { minDirtCount, minDirtFactor } = conditions;\n        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;\n        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;\n        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;\n    }\n    /**\n     * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n     */\n    get isVacuuming() {\n        return this._currentVacuum != null;\n    }\n    /**\n     * The number of documents discarded since the most recent vacuuming\n     */\n    get dirtCount() {\n        return this._dirtCount;\n    }\n    /**\n     * A number between 0 and 1 giving an indication about the proportion of\n     * documents that are discarded, and can therefore be cleaned up by vacuuming.\n     * A value close to 0 means that the index is relatively clean, while a higher\n     * value means that the index is relatively dirty, and vacuuming could release\n     * memory.\n     */\n    get dirtFactor() {\n        return this._dirtCount / (1 + this._documentCount + this._dirtCount);\n    }\n    /**\n     * Returns `true` if a document with the given ID is present in the index and\n     * available for search, `false` otherwise\n     *\n     * @param id  The document ID\n     */\n    has(id) {\n        return this._idToShortId.has(id);\n    }\n    /**\n     * Returns the stored fields (as configured in the `storeFields` constructor\n     * option) for the given document ID. Returns `undefined` if the document is\n     * not present in the index.\n     *\n     * @param id  The document ID\n     */\n    getStoredFields(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            return undefined;\n        }\n        return this._storedFields.get(shortId);\n    }\n    /**\n     * Search for documents matching the given search query.\n     *\n     * The result is a list of scored document IDs matching the query, sorted by\n     * descending score, and each including data about which terms were matched and\n     * in which fields.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Search for \"zen art motorcycle\" with default options: terms have to match\n     * // exactly, and individual terms are joined with OR\n     * miniSearch.search('zen art motorcycle')\n     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n     * ```\n     *\n     * ### Restrict search to specific fields:\n     *\n     * ```javascript\n     * // Search only in the 'title' field\n     * miniSearch.search('zen', { fields: ['title'] })\n     * ```\n     *\n     * ### Field boosting:\n     *\n     * ```javascript\n     * // Boost a field\n     * miniSearch.search('zen', { boost: { title: 2 } })\n     * ```\n     *\n     * ### Prefix search:\n     *\n     * ```javascript\n     * // Search for \"moto\" with prefix search (it will match documents\n     * // containing terms that start with \"moto\" or \"neuro\")\n     * miniSearch.search('moto neuro', { prefix: true })\n     * ```\n     *\n     * ### Fuzzy search:\n     *\n     * ```javascript\n     * // Search for \"ismael\" with fuzzy search (it will match documents containing\n     * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n     * // (rounded to nearest integer)\n     * miniSearch.search('ismael', { fuzzy: 0.2 })\n     * ```\n     *\n     * ### Combining strategies:\n     *\n     * ```javascript\n     * // Mix of exact match, prefix search, and fuzzy search\n     * miniSearch.search('ismael mob', {\n     *  prefix: true,\n     *  fuzzy: 0.2\n     * })\n     * ```\n     *\n     * ### Advanced prefix and fuzzy search:\n     *\n     * ```javascript\n     * // Perform fuzzy and prefix search depending on the search term. Here\n     * // performing prefix and fuzzy search only on terms longer than 3 characters\n     * miniSearch.search('ismael mob', {\n     *  prefix: term => term.length > 3\n     *  fuzzy: term => term.length > 3 ? 0.2 : null\n     * })\n     * ```\n     *\n     * ### Combine with AND:\n     *\n     * ```javascript\n     * // Combine search terms with AND (to match only documents that contain both\n     * // \"motorcycle\" and \"art\")\n     * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n     * ```\n     *\n     * ### Combine with AND_NOT:\n     *\n     * There is also an AND_NOT combinator, that finds documents that match the\n     * first term, but do not match any of the other terms. This combinator is\n     * rarely useful with simple queries, and is meant to be used with advanced\n     * query combinations (see later for more details).\n     *\n     * ### Filtering results:\n     *\n     * ```javascript\n     * // Filter only results in the 'fiction' category (assuming that 'category'\n     * // is a stored field)\n     * miniSearch.search('motorcycle art', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Wildcard query\n     *\n     * Searching for an empty string (assuming the default tokenizer) returns no\n     * results. Sometimes though, one needs to match all documents, like in a\n     * \"wildcard\" search. This is possible by passing the special value\n     * {@link MiniSearch.wildcard} as the query:\n     *\n     * ```javascript\n     * // Return search results for all documents\n     * miniSearch.search(MiniSearch.wildcard)\n     * ```\n     *\n     * Note that search options such as `filter` and `boostDocument` are still\n     * applied, influencing which results are returned, and their order:\n     *\n     * ```javascript\n     * // Return search results for all documents in the 'fiction' category\n     * miniSearch.search(MiniSearch.wildcard, {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Advanced combination of queries:\n     *\n     * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n     * and even with different search options, by passing a query expression\n     * tree object as the first argument, instead of a string.\n     *\n     * ```javascript\n     * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n     * miniSearch.search({\n     *   combineWith: 'AND',\n     *   queries: [\n     *     'zen',\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['motorcycle', 'archery']\n     *     }\n     *   ]\n     * })\n     *\n     * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n     * // not \"tree\"\n     * miniSearch.search({\n     *   combineWith: 'AND_NOT',\n     *   queries: [\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['apple', 'pear']\n     *     },\n     *     'juice',\n     *     'tree'\n     *   ]\n     * })\n     * ```\n     *\n     * Each node in the expression tree can be either a string, or an object that\n     * supports all {@link SearchOptions} fields, plus a `queries` array field for\n     * subqueries.\n     *\n     * Note that, while this can become complicated to do by hand for complex or\n     * deeply nested queries, it provides a formalized expression tree API for\n     * external libraries that implement a parser for custom query languages.\n     *\n     * @param query  Search query\n     * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n     */\n    search(query, searchOptions = {}) {\n        const { searchOptions: globalSearchOptions } = this._options;\n        const searchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions };\n        const rawResults = this.executeQuery(query, searchOptions);\n        const results = [];\n        for (const [docId, { score, terms, match }] of rawResults) {\n            // terms are the matched query terms, which will be returned to the user\n            // as queryTerms. The quality is calculated based on them, as opposed to\n            // the matched terms in the document (which can be different due to\n            // prefix and fuzzy match)\n            const quality = terms.length || 1;\n            const result = {\n                id: this._documentIds.get(docId),\n                score: score * quality,\n                terms: Object.keys(match),\n                queryTerms: terms,\n                match\n            };\n            Object.assign(result, this._storedFields.get(docId));\n            if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n                results.push(result);\n            }\n        }\n        // If it's a wildcard query, and no document boost is applied, skip sorting\n        // the results, as all results have the same score of 1\n        if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n            return results;\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Provide suggestions for the given search query\n     *\n     * The result is a list of suggested modified search queries, derived from the\n     * given search query, each with a relevance score, sorted by descending score.\n     *\n     * By default, it uses the same options used for search, except that by\n     * default it performs prefix search on the last term of the query, and\n     * combine terms with `'AND'` (requiring all query terms to match). Custom\n     * options can be passed as a second argument. Defaults can be changed upon\n     * calling the {@link MiniSearch} constructor, by passing a\n     * `autoSuggestOptions` option.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Get suggestions for 'neuro':\n     * miniSearch.autoSuggest('neuro')\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n     * ```\n     *\n     * ### Multiple words:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar':\n     * miniSearch.autoSuggest('zen ar')\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * ### Fuzzy suggestions:\n     *\n     * ```javascript\n     * // Correct spelling mistakes using fuzzy search:\n     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n     * ```\n     *\n     * ### Filtering:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar', but only within the 'fiction' category\n     * // (assuming that 'category' is a stored field):\n     * miniSearch.autoSuggest('zen ar', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * @param queryString  Query string to be expanded into suggestions\n     * @param options  Search options. The supported options and default values\n     * are the same as for the {@link MiniSearch#search} method, except that by\n     * default prefix search is performed on the last term in the query, and terms\n     * are combined with `'AND'`.\n     * @return  A sorted array of suggestions sorted by relevance score.\n     */\n    autoSuggest(queryString, options = {}) {\n        options = { ...this._options.autoSuggestOptions, ...options };\n        const suggestions = new Map();\n        for (const { score, terms } of this.search(queryString, options)) {\n            const phrase = terms.join(' ');\n            const suggestion = suggestions.get(phrase);\n            if (suggestion != null) {\n                suggestion.score += score;\n                suggestion.count += 1;\n            }\n            else {\n                suggestions.set(phrase, { score, terms, count: 1 });\n            }\n        }\n        const results = [];\n        for (const [suggestion, { score, terms, count }] of suggestions) {\n            results.push({ suggestion, terms, score: score / count });\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Total number of documents available to search\n     */\n    get documentCount() {\n        return this._documentCount;\n    }\n    /**\n     * Number of terms in the index\n     */\n    get termCount() {\n        return this._index.size;\n    }\n    /**\n     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n     * and instantiates a MiniSearch instance. It should be given the same options\n     * originally used when serializing the index.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // If the index was serialized with:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     *\n     * const json = JSON.stringify(miniSearch)\n     * // It can later be deserialized like this:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return An instance of MiniSearch deserialized from the given JSON.\n     */\n    static loadJSON(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJS(JSON.parse(json), options);\n    }\n    /**\n     * Async equivalent of {@link MiniSearch.loadJSON}\n     *\n     * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n     * a promise, and loads the index in batches, leaving pauses between them to avoid\n     * blocking the main thread. It tends to be slower than the synchronous\n     * version, but does not block the main thread, so it can be a better choice\n     * when deserializing very large indexes.\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n     */\n    static async loadJSONAsync(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJSAsync(JSON.parse(json), options);\n    }\n    /**\n     * Returns the default value of an option. It will throw an error if no option\n     * with the given name exists.\n     *\n     * @param optionName  Name of the option\n     * @return The default value of the given option\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Get default tokenizer\n     * MiniSearch.getDefault('tokenize')\n     *\n     * // Get default term processor\n     * MiniSearch.getDefault('processTerm')\n     *\n     * // Unknown options will throw an error\n     * MiniSearch.getDefault('notExisting')\n     * // => throws 'MiniSearch: unknown option \"notExisting\"'\n     * ```\n     */\n    static getDefault(optionName) {\n        if (defaultOptions.hasOwnProperty(optionName)) {\n            return getOwnProperty(defaultOptions, optionName);\n        }\n        else {\n            throw new Error(`MiniSearch: unknown option \"${optionName}\"`);\n        }\n    }\n    /**\n     * @ignore\n     */\n    static loadJS(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = objectToNumericMap(documentIds);\n        miniSearch._fieldLength = objectToNumericMap(fieldLength);\n        miniSearch._storedFields = objectToNumericMap(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));\n            }\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static async loadJSAsync(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = await objectToNumericMapAsync(documentIds);\n        miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength);\n        miniSearch._storedFields = await objectToNumericMapAsync(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        let count = 0;\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry));\n            }\n            if (++count % 1000 === 0)\n                await wait(0);\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static instantiateMiniSearch(js, options) {\n        const { documentCount, nextId, fieldIds, averageFieldLength, dirtCount, serializationVersion } = js;\n        if (serializationVersion !== 1 && serializationVersion !== 2) {\n            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');\n        }\n        const miniSearch = new MiniSearch(options);\n        miniSearch._documentCount = documentCount;\n        miniSearch._nextId = nextId;\n        miniSearch._idToShortId = new Map();\n        miniSearch._fieldIds = fieldIds;\n        miniSearch._avgFieldLength = averageFieldLength;\n        miniSearch._dirtCount = dirtCount || 0;\n        miniSearch._index = new SearchableMap();\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    executeQuery(query, searchOptions = {}) {\n        if (query === MiniSearch.wildcard) {\n            return this.executeWildcardQuery(searchOptions);\n        }\n        if (typeof query !== 'string') {\n            const options = { ...searchOptions, ...query, queries: undefined };\n            const results = query.queries.map((subquery) => this.executeQuery(subquery, options));\n            return this.combineResults(results, options.combineWith);\n        }\n        const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options;\n        const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions };\n        const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options;\n        const terms = searchTokenize(query)\n            .flatMap((term) => searchProcessTerm(term))\n            .filter((term) => !!term);\n        const queries = terms.map(termToQuerySpec(options));\n        const results = queries.map(query => this.executeQuerySpec(query, options));\n        return this.combineResults(results, options.combineWith);\n    }\n    /**\n     * @ignore\n     */\n    executeQuerySpec(query, searchOptions) {\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        const boosts = (options.fields || this._options.fields).reduce((boosts, field) => ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {});\n        const { boostDocument, weights, maxFuzzy, bm25: bm25params } = options;\n        const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights };\n        const data = this._index.get(query.term);\n        const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params);\n        let prefixMatches;\n        let fuzzyMatches;\n        if (query.prefix) {\n            prefixMatches = this._index.atPrefix(query.term);\n        }\n        if (query.fuzzy) {\n            const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;\n            const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;\n            if (maxDistance)\n                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);\n        }\n        if (prefixMatches) {\n            for (const [term, data] of prefixMatches) {\n                const distance = term.length - query.term.length;\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Delete the term from fuzzy results (if present) if it is also a\n                // prefix result. This entry will always be scored as a prefix result.\n                fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to prefixWeight.\n                // The rate of change is much lower than that of fuzzy matches to\n                // account for the fact that prefix matches stay more relevant than\n                // fuzzy matches for longer distances.\n                const weight = prefixWeight * term.length / (term.length + 0.3 * distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        if (fuzzyMatches) {\n            for (const term of fuzzyMatches.keys()) {\n                const [data, distance] = fuzzyMatches.get(term);\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n                const weight = fuzzyWeight * term.length / (term.length + distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    executeWildcardQuery(searchOptions) {\n        const results = new Map();\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        for (const [shortId, id] of this._documentIds) {\n            const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;\n            results.set(shortId, {\n                score,\n                terms: [],\n                match: {}\n            });\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    combineResults(results, combineWith = OR) {\n        if (results.length === 0) {\n            return new Map();\n        }\n        const operator = combineWith.toLowerCase();\n        const combinator = combinators[operator];\n        if (!combinator) {\n            throw new Error(`Invalid combination operator: ${combineWith}`);\n        }\n        return results.reduce(combinator) || new Map();\n    }\n    /**\n     * Allows serialization of the index to JSON, to possibly store it and later\n     * deserialize it with {@link MiniSearch.loadJSON}.\n     *\n     * Normally one does not directly call this method, but rather call the\n     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n     * instance, and JavaScript will internally call this method. Upon\n     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n     * options used to create the original instance that was serialized.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Serialize the index:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     * const json = JSON.stringify(miniSearch)\n     *\n     * // Later, to deserialize it:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @return A plain-object serializable representation of the search index.\n     */\n    toJSON() {\n        const index = [];\n        for (const [term, fieldIndex] of this._index) {\n            const data = {};\n            for (const [fieldId, freqs] of fieldIndex) {\n                data[fieldId] = Object.fromEntries(freqs);\n            }\n            index.push([term, data]);\n        }\n        return {\n            documentCount: this._documentCount,\n            nextId: this._nextId,\n            documentIds: Object.fromEntries(this._documentIds),\n            fieldIds: this._fieldIds,\n            fieldLength: Object.fromEntries(this._fieldLength),\n            averageFieldLength: this._avgFieldLength,\n            storedFields: Object.fromEntries(this._storedFields),\n            dirtCount: this._dirtCount,\n            index,\n            serializationVersion: 2\n        };\n    }\n    /**\n     * @ignore\n     */\n    termResults(sourceTerm, derivedTerm, termWeight, termBoost, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results = new Map()) {\n        if (fieldTermData == null)\n            return results;\n        for (const field of Object.keys(fieldBoosts)) {\n            const fieldBoost = fieldBoosts[field];\n            const fieldId = this._fieldIds[field];\n            const fieldTermFreqs = fieldTermData.get(fieldId);\n            if (fieldTermFreqs == null)\n                continue;\n            let matchingFields = fieldTermFreqs.size;\n            const avgFieldLength = this._avgFieldLength[fieldId];\n            for (const docId of fieldTermFreqs.keys()) {\n                if (!this._documentIds.has(docId)) {\n                    this.removeTerm(fieldId, docId, derivedTerm);\n                    matchingFields -= 1;\n                    continue;\n                }\n                const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;\n                if (!docBoost)\n                    continue;\n                const termFreq = fieldTermFreqs.get(docId);\n                const fieldLength = this._fieldLength.get(docId)[fieldId];\n                // NOTE: The total number of fields is set to the number of documents\n                // `this._documentCount`. It could also make sense to use the number of\n                // documents where the current field is non-blank as a normalization\n                // factor. This will make a difference in scoring if the field is rarely\n                // present. This is currently not supported, and may require further\n                // analysis to see if it is a valid use case.\n                const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);\n                const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore;\n                const result = results.get(docId);\n                if (result) {\n                    result.score += weightedScore;\n                    assignUniqueTerm(result.terms, sourceTerm);\n                    const match = getOwnProperty(result.match, derivedTerm);\n                    if (match) {\n                        match.push(field);\n                    }\n                    else {\n                        result.match[derivedTerm] = [field];\n                    }\n                }\n                else {\n                    results.set(docId, {\n                        score: weightedScore,\n                        terms: [sourceTerm],\n                        match: { [derivedTerm]: [field] }\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    addTerm(fieldId, documentId, term) {\n        const indexData = this._index.fetch(term, createMap);\n        let fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null) {\n            fieldIndex = new Map();\n            fieldIndex.set(documentId, 1);\n            indexData.set(fieldId, fieldIndex);\n        }\n        else {\n            const docs = fieldIndex.get(documentId);\n            fieldIndex.set(documentId, (docs || 0) + 1);\n        }\n    }\n    /**\n     * @ignore\n     */\n    removeTerm(fieldId, documentId, term) {\n        if (!this._index.has(term)) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n            return;\n        }\n        const indexData = this._index.fetch(term, createMap);\n        const fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n        }\n        else if (fieldIndex.get(documentId) <= 1) {\n            if (fieldIndex.size <= 1) {\n                indexData.delete(fieldId);\n            }\n            else {\n                fieldIndex.delete(documentId);\n            }\n        }\n        else {\n            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);\n        }\n        if (this._index.get(term).size === 0) {\n            this._index.delete(term);\n        }\n    }\n    /**\n     * @ignore\n     */\n    warnDocumentChanged(shortDocumentId, fieldId, term) {\n        for (const fieldName of Object.keys(this._fieldIds)) {\n            if (this._fieldIds[fieldName] === fieldId) {\n                this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict');\n                return;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    addDocumentId(documentId) {\n        const shortDocumentId = this._nextId;\n        this._idToShortId.set(documentId, shortDocumentId);\n        this._documentIds.set(shortDocumentId, documentId);\n        this._documentCount += 1;\n        this._nextId += 1;\n        return shortDocumentId;\n    }\n    /**\n     * @ignore\n     */\n    addFields(fields) {\n        for (let i = 0; i < fields.length; i++) {\n            this._fieldIds[fields[i]] = i;\n        }\n    }\n    /**\n     * @ignore\n     */\n    addFieldLength(documentId, fieldId, count, length) {\n        let fieldLengths = this._fieldLength.get(documentId);\n        if (fieldLengths == null)\n            this._fieldLength.set(documentId, fieldLengths = []);\n        fieldLengths[fieldId] = length;\n        const averageFieldLength = this._avgFieldLength[fieldId] || 0;\n        const totalFieldLength = (averageFieldLength * count) + length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);\n    }\n    /**\n     * @ignore\n     */\n    removeFieldLength(documentId, fieldId, count, length) {\n        if (count === 1) {\n            this._avgFieldLength[fieldId] = 0;\n            return;\n        }\n        const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);\n    }\n    /**\n     * @ignore\n     */\n    saveStoredFields(documentId, doc) {\n        const { storeFields, extractField } = this._options;\n        if (storeFields == null || storeFields.length === 0) {\n            return;\n        }\n        let documentFields = this._storedFields.get(documentId);\n        if (documentFields == null)\n            this._storedFields.set(documentId, documentFields = {});\n        for (const fieldName of storeFields) {\n            const fieldValue = extractField(doc, fieldName);\n            if (fieldValue !== undefined)\n                documentFields[fieldName] = fieldValue;\n        }\n    }\n}\n/**\n * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n * to match all documents\n */\nMiniSearch.wildcard = Symbol('*');\nconst getOwnProperty = (object, property) => Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\nconst combinators = {\n    [OR]: (a, b) => {\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null) {\n                a.set(docId, b.get(docId));\n            }\n            else {\n                const { score, terms, match } = b.get(docId);\n                existing.score = existing.score + score;\n                existing.match = Object.assign(existing.match, match);\n                assignUniqueTerms(existing.terms, terms);\n            }\n        }\n        return a;\n    },\n    [AND]: (a, b) => {\n        const combined = new Map();\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null)\n                continue;\n            const { score, terms, match } = b.get(docId);\n            assignUniqueTerms(existing.terms, terms);\n            combined.set(docId, {\n                score: existing.score + score,\n                terms: existing.terms,\n                match: Object.assign(existing.match, match)\n            });\n        }\n        return combined;\n    },\n    [AND_NOT]: (a, b) => {\n        for (const docId of b.keys())\n            a.delete(docId);\n        return a;\n    }\n};\nconst defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };\nconst calcBM25Score = (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) => {\n    const { k, b, d } = bm25params;\n    const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));\n};\nconst termToQuerySpec = (options) => (term, i, terms) => {\n    const fuzzy = (typeof options.fuzzy === 'function')\n        ? options.fuzzy(term, i, terms)\n        : (options.fuzzy || false);\n    const prefix = (typeof options.prefix === 'function')\n        ? options.prefix(term, i, terms)\n        : (options.prefix === true);\n    const termBoost = (typeof options.boostTerm === 'function')\n        ? options.boostTerm(term, i, terms)\n        : 1;\n    return { term, fuzzy, prefix, termBoost };\n};\nconst defaultOptions = {\n    idField: 'id',\n    extractField: (document, fieldName) => document[fieldName],\n    tokenize: (text) => text.split(SPACE_OR_PUNCTUATION),\n    processTerm: (term) => term.toLowerCase(),\n    fields: undefined,\n    searchOptions: undefined,\n    storeFields: [],\n    logger: (level, message) => {\n        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')\n            console[level](message);\n    },\n    autoVacuum: true\n};\nconst defaultSearchOptions = {\n    combineWith: OR,\n    prefix: false,\n    fuzzy: false,\n    maxFuzzy: 6,\n    boost: {},\n    weights: { fuzzy: 0.45, prefix: 0.375 },\n    bm25: defaultBM25params\n};\nconst defaultAutoSuggestOptions = {\n    combineWith: AND,\n    prefix: (term, i, terms) => i === terms.length - 1\n};\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions };\nconst assignUniqueTerm = (target, term) => {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term))\n        target.push(term);\n};\nconst assignUniqueTerms = (target, source) => {\n    for (const term of source) {\n        // Avoid adding duplicate terms.\n        if (!target.includes(term))\n            target.push(term);\n    }\n};\nconst byScore = ({ score: a }, { score: b }) => b - a;\nconst createMap = () => new Map();\nconst objectToNumericMap = (object) => {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n    }\n    return map;\n};\nconst objectToNumericMapAsync = async (object) => {\n    const map = new Map();\n    let count = 0;\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n        if (++count % 1000 === 0) {\n            await wait(0);\n        }\n    }\n    return map;\n};\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u;\n\nexport { MiniSearch as default };\n//# sourceMappingURL=index.js.map\n"],"names":["ENTRIES","KEYS","VALUES","LEAF","TreeIterator","set","type","node","keys","value","last$1","child","key","array","fuzzySearch","query","maxDistance","results","m","matrix","j","i","recurse","n","prefix","offset","distance","pos","char","thisRowOffset","prevRowOffset","minDistance","jmin","jmax","different","rpl","del","ins","dist","SearchableMap","tree","path","trackDown","parentNode","last","k","remove","fn","maxEditDistance","lookup","createPath","iter","initial","entries","object","keyLength","outer","len","intermediate","cleanup","merge","nodeKey","OR","AND","AND_NOT","MiniSearch","options","autoVacuum","defaultAutoVacuumOptions","defaultOptions","defaultSearchOptions","defaultAutoSuggestOptions","defaultVacuumConditions","document","extractField","tokenize","processTerm","fields","idField","id","shortDocumentId","field","fieldValue","tokens","fieldId","uniqueTerms","term","processedTerm","t","documents","chunkSize","acc","chunk","promise","resolve","shortId","fieldLength","minDirtFactor","minDirtCount","batchSize","batchWait","ids","updatedDocument","conditions","initialDirtCount","defaultVacuumOptions","fieldsData","fieldIndex","searchOptions","globalSearchOptions","searchOptionsWithDefaults","rawResults","docId","score","terms","match","quality","result","byScore","queryString","suggestions","phrase","suggestion","count","json","optionName","getOwnProperty","js","index","documentIds","storedFields","serializationVersion","miniSearch","objectToNumericMap","data","dataMap","indexEntry","objectToNumericMapAsync","wait","documentCount","nextId","fieldIds","averageFieldLength","dirtCount","subquery","searchTokenize","searchProcessTerm","termToQuerySpec","boosts","boostDocument","weights","maxFuzzy","bm25params","fuzzyWeight","prefixWeight","prefixMatches","fuzzyMatches","fuzzy","weight","combineWith","operator","combinator","combinators","freqs","sourceTerm","derivedTerm","termWeight","termBoost","fieldTermData","fieldBoosts","boostDocumentFn","fieldBoost","fieldTermFreqs","matchingFields","avgFieldLength","docBoost","termFreq","rawScore","calcBM25Score","weightedScore","assignUniqueTerm","documentId","indexData","createMap","docs","fieldName","length","fieldLengths","totalFieldLength","doc","storeFields","documentFields","property","a","b","existing","assignUniqueTerms","combined","defaultBM25params","matchingCount","totalCount","text","SPACE_OR_PUNCTUATION","level","message","target","source","map","ms"],"mappings":"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","x_google_ignoreList":[0]}